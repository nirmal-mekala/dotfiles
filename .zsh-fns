# Auto-Push Commit Message
auto_add_commit_push () {
  current_dir="$PWD"
  if [[ "$current_dir" == *"organize"* || "$current_dir" == *"cw-notes"* || "$current_dir" == *"pensieve"* ]]; then
    date_and_time=$(date '+%Y-%m-%d %H:%M:%S')
    git add -A && git commit -m "pushed via script $date_and_time" && git push
  else
    echo "Whatâ€™s the matter with you?!"
  fi }

# Check if command is installed
check_command() {
  local command_to_check="$1"
  if ! command -v "$command_to_check" > /dev/null 2>&1; then
    echo "Error: $command_to_check is not installed. Exiting."
    return 1
  fi
}

fzf_git_dir() {
  find ~/ghq -maxdepth 3 -mindepth 3 -type d | fzf
}

# Select ghq location with fzf
fhq () {
  check_command fzf || return 1
  cd $(fzf_git_dir)
}


# Change directory to the root of the git repo
gr () {
  local git_dir
  git_dir=$(git rev-parse --show-toplevel 2>/dev/null)
  
  if [[ -n "$git_dir" ]]; then
    cd "$git_dir"
  else
    echo "Not inside a Git repository."
  fi
}

# checkout local branch
gch () {
  local branch
  branch=$(git for-each-ref --format='%(refname:short)' refs/heads | fzf)
  if [[ -z $branch ]]; then
    return 1
  fi
  git checkout "$branch"
}

gdel () {
  local cur
  cur=$(git symbolic-ref --short -q HEAD 2>/dev/null || true)
  if [[ -n $cur ]]; then
    list=$(git for-each-ref --format='%(refname:short)' refs/heads | grep -Fxv -- "$cur")
  else
    list=$(git for-each-ref --format='%(refname:short)' refs/heads)
  fi

  if [[ -z $list ]]; then
    return 1
  fi

  local sel
  sel=$(print -r -- "$list" | fzf -m)
  if [[ -z $sel ]]; then
    return 1
  fi
  print -r -- "$sel" | xargs -r -n1 git branch -d --
}

# Exa Functions
ll () {
  if command -v eza > /dev/null 2>&1 ; then
    eza --long --icons --git --group "$@"
  elif command -v exa > /dev/null 2>&1 ; then
    exa --long --icons --git --group "$@"
  else
    ls -l "$@"
  fi
}

xt () {
  if command -v eza > /dev/null 2>&1 ; then
    eza --long --icons --git --group --tree --git-ignore "$@"
  elif command -v exa > /dev/null 2>&1 ; then
    exa --long --icons --git --group --tree --git-ignore "$@"
  else
    echo "Exa is not installed!"
  fi
}


### ghq

ghq() {
  if whence -p ghq > /dev/null 2>&1 ; then
    command ghq "$@"
  else
    ghqShellVersion "$@"
  fi
}

ghqShellVersion() {
  # Function to display usage instructions
  usage() {
      echo "Usage: ghq get <repository_url>"
      echo "       ghq list"
  }

  get_repo() {
    repo_url=$1
    if [[ $repo_url == *@* ]]; then
        # SSH format (with or without .git)
        domain=$(echo "$repo_url" | awk -F'[@:/]' '{print $2}')
        user=$(echo "$repo_url" | awk -F'[@:/]' '{print $3}')
        repo=$(echo "$repo_url" | awk -F'[@:/]' '{print $4}' | sed 's/\.git$//')
    else
        # HTTPS format (with or without .git)
        domain=$(echo "$repo_url" | awk -F/ '{print $(NF-2)}')
        user=$(echo "$repo_url" | awk -F/ '{print $(NF-1)}')
        repo=$(echo "$repo_url" | awk -F/ '{print $(NF)}' | sed 's/\.git$//')
    fi
    if [[ -n "$domain" && -n "$user" && -n "$repo" ]]; then
      target_dir="$HOME/ghq/$domain/$user/$repo"
      mkdir -p "$target_dir"
      git clone $repo_url $target_dir
    else
      echo "Error: Invalid repository URL format."
      usage
      return 1
    fi
  }

  # Check if the first argument is 'get'
  if [[ $1 == "get" && $# -eq 2 ]]; then
      get_repo $2
  elif [[ $1 == "list" ]]; then
      find $HOME/ghq -maxdepth 3 -mindepth 3 -type d 
  else
      usage
      return 1
  fi
}


# BW password
bwutil () {
  check_command bw || return 1
  check_command fzf || return 1
  check_command fx || return 1

  # password data in a variable
  bw_items_json="$(bw list items)"
  # convert to name and id
  bw_name_id="$(printf '%s\n' "$bw_items_json"| fx '.map(x => [x.name.slice(0, 45), " ".repeat(50 - x.name.slice(0,45).length), x.id].join(""))' list)"
  # get a specific id
  bw_id="$(printf '%s\n' "$bw_name_id" | fzf | cut -c 51-)"

  username=$(printf '%s\n' "$bw_items_json" | fx ".find(x => x.id === \"$bw_id\")?.login?.username" | tr -d '\n')
  password=$(printf '%s\n' "$bw_items_json" | fx ".find(x => x.id === \"$bw_id\")?.login?.password" | tr -d '\n')

  # output
  echo "Username: $username"
  if command -v pbcopy > /dev/null 2>&1; then
    echo -n $password | pbcopy
  else
    echo -n $password | xclip -selection clipboard
  fi
  echo "Password copied"
}

# timers

function play() {
  ffplay -nodisp -autoexit -af "volume=0.7" $1 > /dev/null 2>&1
}

parse_time_input() {
  local _target_var="$1"
  local _arg="$2"
  local _result

  if [ -z "$_arg" ]; then
    echo -n "Enter time expression (e.g. 1.5 * 30): "
    read _input || return 1
    _result=$(echo "$_input" | bc)
  else
    _result=$(echo "$_arg" | bc)
  fi

  # Assign to the passed variable name
  printf -v "$_target_var" '%s' "$_result"
}


function ts() {
  check_command ffplay || return 1
  check_command figlet || return 1
  [ -e "$HOME/.timer/start.m4a" ] || { echo "Error: ~/.timer/start.m4a does not exist!" >&2; return 1; }
  [ -e "$HOME/.timer/end.m4a" ] || { echo "Error: ~/.timer/end.m4a does not exist!" >&2; return 1; }

  parse_time_input time_input "$1" || return 1

  play "$HOME/.timer/start.m4a"

  end_time=$(( $(date +%s) + $time_input ))
  clear
  tput civis

  # Track interruption
  local interrupted=0

  # Define cleanup function
  cleanup() {
    interrupted=1
  }

  # Trap Ctrl+C (SIGINT) and other termination signals
  trap cleanup INT TERM

  while [ "$(date +%s)" -lt "$end_time" ]; do
    if (( interrupted )); then
      break
    fi
    remaining=$(( end_time - $(date +%s) - 1 ))
    hours=$(( remaining / 3600 ))
    minutes=$(( (remaining % 3600) / 60 ))
    seconds=$(( remaining % 60 ))
  
    time_str=$(printf "%02d:%02d:%02d" $hours $minutes $seconds)
  
    # Move to top-left
    tput cup 0 0
  
    # Save figlet output to variable
    figlet_output=$(figlet -f 'ANSI Shadow' "$time_str")
  
    # Determine terminal size
    term_width=$(tput cols)
  
    # Get number of lines and max line width in the figlet output
    line_count=$(echo "$figlet_output" | wc -l)
    max_line_width=$(echo "$figlet_output" | awk '{ print length }' | sort -nr | head -1)
  
    # Clear previous output
    for ((i = 0; i < line_count + 2; i++)); do
      printf '%*s\n' "$term_width" ''
    done
  
    # Move back to top
    tput cup 0 0
  
    # Optional: center any message passed as $2
    if [ -n "$2" ]; then
      msg_pad=$(( (term_width - ${#2}) / 2 ))
      printf "%*s%s\n\n" "$msg_pad" "" "$2"
    else
      echo ""
    fi
  
    # Print centered figlet output
    while IFS= read -r line; do
      padding=$(( (term_width - ${#line}) / 2 ))
      printf "%*s%s\n" "$padding" "" "$line"
    done <<< "$figlet_output"
  
    sleep 1
  done

  tput cnorm
  echo ""

  if (( interrupted )); then
    return 1
  fi

  play "$HOME/.timer/end.m4a"
}

function tm() {
  parse_time_input time_input "$1" || return 1
  ts $(( $time_input * 60 )) "Timer set for $time_input minutes"
}

function th() {
  parse_time_input time_input "$1" || return 1
  ts $(( $time_input * 60 * 60 )) "Timer set for $time_input hours"
}

function rmnl() {
  awk '{printf "%s", $0}'
}

function vzf() {
  fzf --preview="cat {}" --bind 'enter:become(nvim {})'
}


function fh() {
  # List history without numbers, reverse so newest are first,
  # escape backslashes, then fuzzy-find and eval.
  eval "$(fc -ln 1 | tac | sed -E 's/\\/\\\\/g' | fzf)"
}

function mkncd() { mkdir -p "$1" && cd "$1"; }

# TMUX

mxq() {
  local git_dir=$(fzf_git_dir)
  if [[ -n "$git_dir" ]]; then
    mx "$git_dir"
  fi
}

function mxc() {
  tmux choose-tree -sw
}

function mxl() {
  tmux list-sessions
}

function mx() {
  emulate -L zsh
  setopt pipefail

  local input session dir

  if [[ -n "$1" ]]; then
    input="$1"
  fi

  if [[ -n "$input" ]]; then
    if [[ -d "$input" ]]; then
      dir=$(realpath "$input")
      session=$(basename "$dir" | tr '.' '_')
    else
      session="$input"
    fi
    if ! tmux list-sessions -F '#S' | grep -Fxq "$session"; then
      tmux new-session -d -s "$session" -c "$dir"
    fi
  else
    local sessions
    sessions=$(tmux ls | grep -v "attached")
    if [[ -z "$sessions" ]]; then
      echo "No available (detached) tmux sessions."
      echo "You can supply a name or directory as an argument to create one."
      return 0
    fi
    session=$(echo "$sessions" | fzf | awk '{print $1}' | sed 's/://' )
    if [[ -z "$session" ]]; then
      return 0
    fi
  fi

  if [[ -z "$TMUX" ]]; then
    tmux attach-session -t "$session"
  else
    tmux switch-client -t "$session"
  fi
}

function mxk() {
  sessions="$(tmux ls | awk '{print $1}' | sed 's/://' | fzf --multi)"
  echo "$sessions" | while IFS= read -r session; do
    [ -n "$session" ] && tmux kill-session -t "$session"
  done
}

function mxd() {
  tmux detach
}

function ks() {
  lsof -i @localhost | tail -n +2 | fzf --multi | awk {'print $2'} | xargs -I{} kill -9 {}
}

function lk {
  cd "$(walk --icons --preview "$@")"
}
